# 효율적인 화폐 구성

> 난이도 🧡🧡🤍 | 풀이시간 30분 | 시간제한 1초 | 메모리 제한 128MB

N 가지 종류의 화폐가 있다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M 원이 되도록 하려고 한다. 이때 각 화폐는 몇 개라도 사용할 수 있으며, 사용한 화폐의 구성은 같지만 순서만 다른 것은 같은 경우로 구분한다. 예를들어 2원, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의 화폐 개수이다.

* 입력조건
  * 첫째 줄에 N, M 이 주어진다. (`1 <= N <= 10,000`)
  * 이후 N 개의 줄에는 각 화폐의 가치가 주어진다. 화폐 가치는 `10,000` 보다 작거나 같은 자연수이다.
* 출력 조건
  * 첫째 줄에 M 원을 만들기 위한 최소한의 화폐 개수를 출력한다.
  * 불가능할 때는 `-1` 를 출력한다.
* 입력 예시 1

``` python
2 15
2
3
```

* 출력 예시 1

``` python
5
```

* 입력 예시 2

``` python
3 4
3
5
7
```

* 출력 예시 2

``` python
-1
```

## 책 답안 예시

``` python
# 정수 N, M 을 입력받기
n, m = map(int, input().split())

# N 개의 화폐 단위 정보를 입력받기
array = []
for i in range(n):
    array.append(int(input()))
    
# print(array)


# 한 번 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [10001] * (m + 1)

# 다이나믹 프로그래밍 (Dynamic Programming) 진행 (바텀업)
d[0] = 0
for i in range(n):
    for j in range(array[i], m + 1):
        print(int(i))
        # (i - k) 원을 만드는 방법이 존재하는 경우
        if (d[j - array[i]]) != 10001:
            d[j] = min(d[j], d[j - array[i]] + 1)
            
# 계산된 결과 출력
if (d[m] == 10001): print(-1)
else: print(d[m])
```