# 1로 만들기

> 난이도 🧡💛🤍 | 풀이시간 20분 | 시간제한 1초 | 메모리 제한 128MB

정수 X 가 주어질 때 정수 X 에 사용할 수 있는 연산은 다음과 같이 4가지 이다.

1. X 가 5로 나누어떨어지면, 5로 나눈다.
2. X 가 3으로 나누어떨어지면, 3로 나눈다.
3. X 가 2으로 나누어떨어지면, 2로 나눈다.
4. X 에서 1 을 뺀다.

정수 X 가 주어졌을 때, 연산 4 개를 적절히 사용해서 1을 만들려고 한다. **연산을 사용하는 횟수의 최솟값**을 구하시오.

예를들어 정수가 26이면 다음과 같이 계산해서 3번의 연산이 최솟값이다.

```
1. 26 - 1 = 25  (4)
2. 25 / 5 = 5   (1)
3. 5 / 5 = 1    (1)
```

* 입력 조건
  * 첫째 줄에 정수 X가 주어진다. (`1 <= X <= 30,000`)
* 출력 조건
  * 첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.
* 입력 예시

``` python
26
```

* 출력 예시

``` python
3
```

-----


## 책 답안 예시

> 이 문제는 잘 알려진 다이나믹 프로그래밍 문제다. \
> 문제를 풀기 전에 함수가 호출되는 과정을 그림으로 그려보면 이해하는데 도움이 된다. \
> 점화식 끝에 1을 더해주는 이유는 함수의 호출 횟수를 구해야하기 때문이다. (책 참고)

``` python
# 정수 X 를 입력받기
x = int(input())

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 30001

# 다이나믹 프로그래밍 (Dynamic Programming) 진행 (바텀업)
# 2 부터 X + 1 까지 1씩 증가
for i in range(2, x + 1):
  # d[i] 에 저장
  # 현재의 수에서 1을 빼는 경우
  d[i] = d[i - 1] + 1
  
  print('f(' + str(i) + ')', end=' ')

  # 현재의 수가 2로 나누어 떨어지는 경우
  # 저장된 d[i] 번째 값 (기본은 0) vs d[i // n] + 1 값 비교 하여 값에 저장
  if (i % 2 == 0):
    d[i] = min(d[i], d[i // 2] + 1)
    
  # 현재의 수가 3으로 나누어 떨어지는 경우
  if (i % 3 == 0):
    d[i] = min(d[i], d[i // 3] + 1)
    
  # 현재의 수가 5로 나누어 떨어지는 경우
  if (i % 5 == 0):
    d[i] = min(d[i], d[i // 5] + 1)
    
  print(d[i])
    
print(bcolors.OKGREEN + '----' + bcolors.ENDC)
print(bcolors.OKGREEN + 'result: ' + bcolors.ENDC, end=' ')
print(d[x])
```