- [1 이 될 때까지](#1-이-될-때까지)
  - [직접 작성한 답안](#직접-작성한-답안)
  - [책 답안 예시 1](#책-답안-예시-1)
  - [책 답안 예시 2](#책-답안-예시-2)

# 1 이 될 때까지

> 난이도 🧡🤍🤍 | 시간제한 1초 | 메모리 제한 128MB | 기출 2018 E 기업 알고리즘 대회

어떠한 수 `N` 이 `1` 이 될 때까지 다음의 두 과정중 하나를 반복적으로 선택하여 수행하려고 한다. 단, 두 번째 연산은 `N` 이 `K` 로 나누어떨어질 때만 선택할 수 있다.

1. `N` 에서 `1` 을 뺀다.
2. `N` 을 `K` 로 나눈다.

예를들어 `N` 이 `17`, `K` 가 `4` 라고 가정하자. 이때 1 번의 과정을 한 번 수행하면 
`N` 은 `16`이 된다. 이후에 2 번의 과정을 두 번 수행하면 `N` 은 `1` 이 된다. 결과적으로 전체 과정을 실행한 횟수는 `3` 이 된다. 이는 `N` 을 `1` 로 만드는 최소 횟수이다.

`N` 과 `K` 가 주어질 때 `N` 이 `1`이 될 때 까지 1 번 혹은 2 번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성하시오.

* 입력조건
  * 첫째 줄에 `N(2 <= N <= 100,000)` 과 `K(2 <= K <= 100,000)` 가 공백으로 구분되며 각각 자연수로 주어진다. 이때 입력으로 주어지는 `N` 은 항상 `K` 보다 크거나 같다.
* 출력조건
  * 첫째 줄에 n 이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야하는 횟수의 최솟값을 출력한다.
* 입력 예시
``` python
25 5
```

* 출력 예시
``` python
2
```

-------

## 직접 작성한 답안

``` python
# 조건 ::
# 1) N 에서 1 을 뺀다.
# 2) N 을 K 로 나눈다.

n, k = map(int, input().split())

# 횟수 카운트
cnt = 0

while n != 1:
  # print(n)
  if (n % k == 0): n = n / k
  else: n = n - 1
  cnt += 1

  if (cnt > 10): n = 1 

print(cnt)
```

> 풀이 :: 사실 이 풀이는 내가 더 잘한것 같다
```
입력 예시1)  27, 4

[x] 27 ÷ 4 = 6 … 3
[o] 27 - 1 = 26      (1)
[x] 26 ÷ 4 = 6 … 2
[o] 26 - 1 = 25      (1)
[x] 25 ÷ 4 = 6 … 1
[o] 25 - 1 = 24      (1)
[o] 24 ÷ 4 = 6 … 0   (2)
[x] 6 ÷ 4 = 1 … 2
[o] 6 - 1 = 5        (1)
[x] 5 ÷ 4 = 1 … 1
[o] 5 - 1 = 4        (1)
[o] 4 ÷ 4 = 1 … 0    (2)

∴ count (7)

----- 

입력 예시 2)  40, 5

[o] 40 ÷ 5 = 8 … 0   (2)
[x] 8 ÷ 5 = 1 … 3
[o] 8 - 1 = 7        (1)
[x] 7 ÷ 5 = 1 … 2
[o] 7 - 1 = 6        (1)
[x] 6 ÷ 5 = 1 … 1
[o] 6 - 1 = 5        (1)
[o] 5 ÷ 5 = 1 … 0    (2)

∴ count (5)
```

------

## 책 답안 예시 1

> 단순하게 푸는 답안 예시

``` python
n, k = map(int, input().split())

# 횟수 카운트
result = 0

# N이 K 이상이라면 K 로 계속 나누기
while n >= k:
  # print(n, ': n')
  # N이 K로 나누어 떨어지지 않는다면 N 에서 1씩 빼기
  while n % k != 0:
    n -= 1
    result += 1
  
  # K 로 나누기
  n /= k
  result += 1


# 마지막으로 남은 수에 대하여 1 씩 빼기
while n > 1:
  n -= 1
  result += 1

print(result)
```

## 책 답안 예시 2

> 답안 예시 :: 🟨 이건 이해를 못하겠다

``` python
n, k = map(int, input().split())  # 27 4

# 횟수 카운트
result = 0

while True:
  # (N == K 로 나누어 떨어지는 수) 가 될 때까지 1 씩 빼기
  target = (n // k) * k     # (27 / 4) * 4
  result += (n - target)    # 27 - 24 = 3
  print((n // k), k, target, (n - target))
  n = target

  # N 이 K 보다 작을 때 (더이상 나눌 수 없을 때) 반복문 탈출
  if (n < k): break

  # K 로 나누기
  result += 1
  n //= k

# 마지막으로 남은 수에 대하여 1 씩 빼기
result += (n - 1)
print(result)
```
