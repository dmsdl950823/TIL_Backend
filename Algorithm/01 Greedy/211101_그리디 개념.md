
- [그리디 알고리즘](#그리디-알고리즘)
- [문제풀이 방법](#문제풀이-방법)

# 그리디 알고리즘

> 탐욕법 - 단순하지만 강력한 문제 해결 방법 (Greedy = 탐욕) \
> **현재 상황에서 지금 당장 좋은 것만 고르는 방법**

그리디 알고리즘은 **매 순간 가장 좋아보이는 것만 선택**하며, \
현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다. 

코딩 테스트에서 만나게 될 그리드 알고리즘의 문제 유형은, **'사전에 외우고 있지 않아도 풀 수 있을 가능성이 높은 문제 유형'** 이라는 특징이 있다.

그리디 알고리즘 문제는 출제의 폭이 매우 넓기 때문에, 많은 유형을 풀어보며 훈련을 해야한다.\
특정 알고리즘 (다익스트라) 같은 특이 케이스를 제외하고는 **단순 암기를 통해 모든 문제를 대처하기 어렵다**는 점을 이해해야한다. 그리디 알고리즘 유형의 문제는 매우 다양하기 때문에 암기한다고 해서 항상 잘 풀 수 있는 알고리즘 유형이 아니다. 많은 유형을 접해보고 문제를 풀어보며 훈련을 해야한다.

보통 코딩 테스트에서 출제되는 그리디 알고리즘 유형의 문제는 **창의력**, 즉 **문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력**을 요구한다. \
다시말해 특정한 문제를 만났을 때 **단순히 현재 상황에서 가장 좋아보이는 것만 선택**해도 문제를 풀 수 있는지를 파악할 수 있어야한다.

그리디 알고리즘은 **기준에 따라 좋은 것을 선택하는 알고리즘** 이므로, 문제에서 '가장 큰 순서대로', '가장 작은 순서대로' 와 같은 *기준*을 알게 모르게 제시해준다. <sub>대체로 이 기준은 정렬 알고리즘을 사용했을 때 만족시킬 수 있으므로 그리디 알고리즘 문제는 자주 정렬 알고리즘과 짝을 이뤄 출제된다. ex) 거스름돈</sub>

``` javascript
// 거스름돈 예시 코드
function solution (n) {
    let count = 0
    const coin_types = [500, 100, 50, 10]

    for (const coin of coin_types) {
        count += parseInt(n / coin) // 2, 2, 1, 1
        n = n % coin // 260, 60, 10, 0
    }

    return count
}

const result = solution(1260)
console.log(result) // 6
```

그리디 알고리즘은 모든 알고리즘에 적용할 수 있는 것은 아니다.\
**탐욕적으로 문제에 접근했을 때 정확한 답을 찾을 수 있다는 보장이 있을 때는 매우 효과적이고 직관적**이다. 그리디 알고리즘으로 문제의 해법을 찾았을 때는 **그 해법이 정당한지 검토**해야한다. **문제 풀이를 위한 최소한의 아이디어를 떠올리고** 이것이 **정당한지 검토**할 수 있어야 답을 도출할 수 있다. (그리디 알고리즘으로 *최적의 해*를 찾아야 한다)

# 문제풀이 방법

1. 처음에 문제를 만났을 때 바로 다양한 아이디어를 고려하여 **문제 유형을 파악** 한다.
2. 유형을 파악하기 어려운 경우 그리디 알고리즘을 의심하고,\
   탐욕적인 해결법이 존재하는지 다양한 아이디어를 고민한다.
3. 오랜시간을 고민해도 그리디 알고리즘으로 해결 방법을 찾을 수 없다면,\
다이나믹 프로그래밍 / 그래프 알고리즘 등으로 문제를 해결할 수 있는지를 고민한다.
