# 탐색, 자료구조

## 탐색 (Search)
> 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정

프로그래밍에서는 그래프, 트리 등의 자료구조 안에서 탐색을 하는 문제를 자주 다룬다. 대표적인 탐색 알고리즘으로는 *DFS*, *BFS* 를 꼽을 수 있는데, 이 두 알고리즘의 원리를 제대로 이해해야 코딩 테스트의 탐색 문제 유형을 풀 수 있다. 그런데 DFS 와 BFS 를 제대로 이해하려면 기본 자료구조인 스택과 큐에 대한 이해가 전제되어야 한다.

## 자료구조(Data Structure)
> 데이터를 표현, 관리, 처리 하기 위한 구조

스택과 큐를 사용할 때는 삽입/삭제/오버플로우/언더플로우 모두를 고민해야한다.


* **삽입 (Push)** : 데이터 삽입
* **삭제 (Pop)** : 데이터 삭제
* **오버플로 (Overflow)** : 특정한 자료구조가 수용할 수 있는 데이터의 크기를 이미 가득 찬 상태에서 삽입 연산을 수행할 때 발생. \
저장공간을 벗어나 데이터가 넘쳐 흐를 때 발생
* **언더플로 (Underflow)** : 자료구조에 데이터가 전혀 들어있찌 않은 상태에서 삭제 연산을 수행할 때 발생

## 자료구조 종류

### 스택 (Stack)
<img src="../images/211126_Stack.PNG">

> 선입 후출 (First In Last Out) 또는 후입 선출 (Last In First Out) 구조

*재귀 함수(Recursive Function)* 의 연속해서 호출되는 함수는, 메인 메모리의 스택 공간에 적재되므로 스택 자료구조와 같다고 볼 수 있다. \
따라서 스택 자료구조를 활용해야하는 상당수 알고리즘은 **재귀 함수를 이용하여 간편하게 구현할 수 있다.**

### 큐 (Queue)

<img src="../images/211126_Queue.PNG">

> 선입선출 (First In First Out) 구조



### 재귀함수 (Recursive Function)

> 자기 자신을 호출하는 함수

컴퓨터 내부에서 재귀 함수의 수행은 스택 자료구조를 이용한다. \
함수를 계속 호출했을 때 가장 마지막에 호출한 함수가 먼저 수행을 끝내야 그 앞의 호출이 종료되기 때문이다.

연속해서 호출되는 함수는, 메인 메모리의 스택 공간에 적재되므로 재귀 함수는 스택 자료구조와 비슷하다. 스택 자료구조를 활용해야하는 상당수 알고리즘은 재귀함수를 이용하여 구현할 수 있다.

반복문보다 재귀함수를 사용했을 때, 코드가 조금 더 간결해진다는 장점이 있다. 더 간결한 이유는 **재귀함수가 수학의 점화식(재귀식)**을 그대로 소스코드로 옮겼기 때문이다. 수학에서 점화식은 특정한 함수를 자신보다 더 작은 변수에 대한 함수와의 관계로 표현한 것을 의미한다. 이 개념은 '다이나믹 프로그래밍' 으로 이어지기 때문에 중요하다.
#### 계승 (Factorial)
재귀함수를 이용하는 대표적인 예제로는 팩토리얼 문제가 있다.

팩토리얼은 기호로 간단하게 `n!` 로 나타내며, `1`부터 `n` 까지의 자연수를 모두 곱하는것을 의미한다.

```
n! = 1 * 2 * 3 * ... * (n - 1) * n
```

수학적으로 `0!` 과 `1!` 의 값은 `1` 로 같다는 성질을 이용하여, 팩토리얼 함수는 `n` 이 `1` 이하가 되었을 때 함수를 종료하는 재귀함수의 형태로 구현할 수 있다.

-----

팩토리얼을 수학적 점화식으로 표현해보면 다음과 같다.

1. n 이 0 혹은 1 일때 종료 :: $factorial(n) = 1$
2. n 이 1 보다 클 때 종료  :: $factorial(n) = n × factorial(n - 1)$

일반적으로 점화식에서 *종료조건*을 찾을 수 있는데, 두 예시에서 종료 조건은 'n 이 0 혹은 1 일때' 이다. **재귀 함수 내에서 특정 조건일 때 더이상 재귀적으로 함수를 호출하지 않고 종료하도록 `if` 문을 이용하여 꼭 종료 조건을 구현해주어야한다.**

다시 한번 앞의 점화식과 조금 전에 작성했던 팩토리얼 재귀함수 버전을 비교해보면, **재귀함수의 소스코드와 점화식이 매우 닮아있다**는 것을 확인할 수 있다. 