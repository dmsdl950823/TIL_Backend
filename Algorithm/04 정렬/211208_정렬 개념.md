- [정렬 (Sorting)](#정렬-sorting)
  - [선택 정렬](#선택-정렬)
  - [삽입 정렬](#삽입-정렬)
  - [퀵 정렬](#퀵-정렬)
  - [계수 정렬](#계수-정렬)

# 정렬 (Sorting)

> 데이터를 특정한 기준에 따라서 순서대로 나열 하는 것

프로그램에서 데이터를 가공할 때 오름차순이나 내림차순 등 대부분 어떤 식으로든 정렬해서 사용하는 경우가 많기에 정렬 알고리즘은 프로그램을 작성할 때 가장 많이 사용되는 알고리즘 중 하나다. 정렬 알고리즘으로 데이터를 정렬하면 이진 탐색(binary) 이 가능해진다.

보통 정렬 공부하면 '알고리즘의 효율성' 을 쉽게 이해할 수 있어 알고리즘 개론서 초반에 정렬 알고리즘을 설명하는 경우가 많다. 정렬 알고리즘을 공부하다보면 자연스럽게 알고리즘 효율의 중요성을 깨닫는다.

## 선택 정렬

> 데이터가 무작위로 여러 개 있을 때, 이 중에서 **가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복** 하는 알고리즘

``` python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
  min_index = i  # 가장 작은 원소의 인덱스
  for j in range(i + 1, len(array)):
    if (array[min_index] > array[j]):
      min_index = j
      
  # SWAP
  array[i], array[min_index] = array[min_index], array[i]
  
print(array)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

```
N + (N - 1) + (N - 2) + ... + 2
```

* 시간 복잡도 : 이중 반복문으로 인해, `O(N²)`
* 연산 횟수 : `(N² + N) / 2`
* 효율성 : 10,000 개 이상의 데이터에서는 속도가 급격히 느려진다.

선택 정렬은 다소 비효율적이다. 다만 특정한 리스트에서 가장 작은 데이터를 찾는 일이 코딩 테스트에서 잦으므로 선택 정렬 소스코드 형태에 익숙해질 필요가 있다.



## 삽입 정렬

> 특히 필요할 때만 위치를 바꾸므로 **데이터가 거의 정렬되어있을 때 효율적**이다.
> 삽입 정렬은 **특정한 데이터를 적절한 위치에 삽입** 한다는 의미에서 삽입정렬이라고 부른다.

삽입 정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞 까지의 데이터는 이미 정렬되어있다고 가정한다. 정렬되어있는 데이터 리스트에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입된다는 점이 특징이다. 

삽입 정렬은 정렬이 이루어진 원소는 항상 오름차순을 유지하고 있다는 점이 특징이다. 이러한 특징 때문에 삽입 정렬에서는 특정한 데이터가 삽입될 위치를 선정 할 때 (삽입할 위치를 찾기 위하여 왼쪽으로 한 칸씩 이동할 때), 삽입될 데이터보다 작은 데이터를 만나면 그 위치에서 멈추면 된다.

``` python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
  # 인덱스 i 부터 1 까지 감소하여 반복
  for j in range(i, 0, -1):
    # 비교 후 SWAP
    if (array[j] < array[j - 1]):
      array[j],  array[j - 1] = array[j - 1], array[j]
    
    # 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
    else:
      break
      
print(array)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

## 퀵 정렬


## 계수 정렬

