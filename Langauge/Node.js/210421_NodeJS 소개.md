# Node.js

- [Node.js](#nodejs)
- [Node.js 소개](#nodejs-소개)
  - [서버사이드 자바스크립트](#서버사이드-자바스크립트)
  - [Common JS](#common-js)
  - [노드 커뮤니티](#노드-커뮤니티)
  - [노드의 탄생 배경](#노드의-탄생-배경)
    - [Blocking I/O](#blocking-io)
    - [이벤트 루프](#이벤트-루프)

# Node.js 소개

## 서버사이드 자바스크립트
노드는 Javascript로 네트워크 애플리케이션을 작성할 수 있는 플랫폼 입니다. 간단히, **서버사이드 Javascript** 라고 할 수 있습니다.

노드는 웹브라우저에서 사용하던 자바스크립트를 서버사이드에서드 그대로 사용할 수 있도록 만들었습니다. 다시말해 **웹 브라우저에서 사용하는 Javascript의 경험과 지식을 노드에서도 그대로 사용할 수 있음**을 의미합니다.


## Common JS

CommonJS 는 Javascript를 웹 브라우저 외의 환경에서 사용하기 위한 표준입니다. 다시말해 CommonJS 는 웹브라우저 밖에서 JS를 사용하려면 어떤 규칙을 따라야하는지 정해놓은 표준이지 특정한 기술이 아닙니다.

웹브라우저에서의 Javascript 는 HTML 에 `<script>` 태그로 사용되지만, 웹브라우저가 아닌 환경에서는 **모듈화**하기 위한 방법이 필요합니다. 또한 여러 파일로 나눠져있는 JS 코드들이 서로 호출하고 참조하는 방법도 필요합니다. CommonJS 는 이런 방법을 논의하고 표준화하는 프로젝트 입니다.

**노드는 CommonJS 의 표준을 따릅니다**. 노드가 인기를 얻으면서 CommonJS 의 위치도 더욱 확고해졌습니다. 노드를 공부하기위해 CommonJS 표준을 모두 이해할 필요는 없습니다.

## 노드 커뮤니티

노드는 오픈소스 프로젝트로 많은 개발자가 참여중입니다. 창시자인 라이언 달을 중심으로 여러명의 커미터가 노드의 기능이나 소스코드의 적용여부를 결정합니다.

**홀수 버전**은 개발버전, **짝수 버전**은 안정 버전으로 개발됩니다.
먼저 안정버전을 발표하고, 다음 버전을 위한 개발을 시작합니다. 

노드는 Unix 계열의 운영체제를 기반으로 만들어졌습니다.

IT 에서 클라우드가 갖는 비중이 점점 높아지는 가운데 다수의 클라우드 서비스들이 노드를 플랫폼으로 선택해 PaaS (Platform as a Service) 로 제공합니다. 

## 노드의 탄생 배경

라이언은 왜 노드를 만들었을까?

라이언은 I/O 를 다르게 사용해야한다고 생각했다. I/O 는 입력과 출력에 관련한 모든것 (ex. 키보드로 입력, 파일 읽고 쓰기, 데이터베이스나 네트워크의 사용 등) 을 의미합니다. 

### Blocking I/O

``` js
	const result = db.query(‘SELECT * FROM table’)
  // result 수행후 처리...
```

I/O 를 사용할 때 일반적으로 이렇게 작성합니다.

이 코드의 수행 방식은,

1. I/O 를 요청하고,
2. 수행한 결과를 받으면 특정 작업을 수행합니다.

그러나 결과를 받을 때 까지는 아무 일도 안하는 상태로 대기합니다.

다시 말해  I/O 를 동기방식으로 사용하고, I/O 의 수행이 완료될 때까지는 스레드가 블록킹(차단 Blocking)되기 때문에, **블로킹 I/O** (Blocking I/O) 라고 부릅니다.

<img src="https://media.vlpt.us/images/eunjin/post/c63d6950-7ae7-439a-9ee8-d6f145d6808a/Screen%20Shot%202021-01-17%20at%204.18.53%20PM.png" width=700 alt="출처: https://velog.io/@eunjin">


*싱글스레드* 는 I/O 가 결과를 돌려줄 때 까지 스레드는 **더 이상 진행하지 않고 멈춥니다**. I/O 가 결과를 돌렺면 이어서 처리를 시작합니다. (동기적인 구조)

*멀티스레드* 는 여러 개의 스레드가 동시에 동작합니다. 그러나 스레드는 메모리 등 시스템 자원을 많이 차지하기 때문에 무한대로 생성할 순 없습니다. 또한 멀티스레드의 경우 여러 스레드가 동시에 같은 자원을 요청했을 때 서로 먼저 차지하려고 하는 *레이스 상태*(Race Condition) 나, 서로 차지하고있는 자원을 무한정 기다리는 *교착 상태*(Deadlock) 에 빠질 수 있으므로, 신경써서 프로그래밍을 해야합니다.

결론적으로 I/O 를 동기적으로 사용하면 다른 요인에 의해 대기 시간이 길어질 수 있으므로, 효율성이 떨어진다고 생각한 라이언은 🌹 **싱글스레드 기반의 이벤트 루프** (Event Loop) 를 고안해냅니다.

### 이벤트 루프

이벤트 루프 기반 프로그래밍에서는 이벤트 발생에 따라 코드가 실행됩니다.

1. 작업을 요청합니다.
2. 작업의 결과를 기다리는 대신 다른일을 먼저 처리합니다.
3. 요청한 작업이 완료됐다는 이벤트가 발생하면 이벤트 루프가 감지하고 코드를 처리합니다.

``` js
  db.query('SELECT * FROM table', function (result) {
    // result 를 사용합니다.
  })
```
> DB 쿼리를 조회하면서 콜백 함수를 함께 전달합니다.
> 
> 스레드는 결과를 기다리지 않고 이어진 코드를 처리하다가, DB 조회가 완료되었다는 이벤트가 발생하면 콜백 함수를 처리합니다.